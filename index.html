<!--Alejandro Guayaquil-->
<!--09.2015-->

<!--Example to welcome the awesomeness of WebGL-->
<!--I have few knowledge of layouts using HTML and CSS so I will-->
<!--have to improve such skils for this project-->
<!--The same goes for how to code nicely in Javascript-->

<!DOCTYPE html>
<html>
<head>
    <!--What else to put here?-->

    <!--I remembered to seen that JS code-->
    <!--is more efficient at the end of the body-->

    <!--Fetch the math library-->
    <script type="text/javascript" src="gl-matrix-min.js"></script>

<script id="shader-vs" type="x-shader/x-vertex">/// Alejandro Guayaquil 
/// 09.2015 

attribute vec3 aVertexPosition;
attribute vec2 aVertexTexture;
attribute vec3 aVertexNormal;
attribute vec4 aVertexColor;

uniform float uTime;
uniform mat4 uMV;
uniform mat4 uP;

varying vec2 vTexture;
varying vec3 vNormal;
varying vec4 vColor;

void main(void)
{
    vTexture = aVertexTexture;
    vNormal = aVertexNormal;
    vColor = aVertexColor;

    /// Rotation using trigonometry, not matrices
    float x = aVertexPosition.x * cos(uTime);
    float y = aVertexPosition.y;
    float z = aVertexPosition.z * sin(uTime);

    gl_Position = uP * uMV * vec4(vec3(x, y, z), 1.0);
}</script>

<script id="shader-fs" type="x-shader/x-fragment">/// Alejandro Guayaquil
/// 09.2015

/// Check what is the purpose of this line
precision mediump float;

varying vec2 vTexture;
varying vec3 vNormal;
varying vec4 vColor;

void main(void)
{
    gl_FragColor = vColor;
}</script>

    <script type="text/javascript">
        /// Create context and dimensions
        var shadersOK = false;
        var gl;

        function initGL(canvas)
        {
            /// Do not pay attention to the try-catch block
            /// In programming is a "way" of coding safe stuff
            try
            {
                /// Search about the Context argument
                /// http://www.w3schools.com/tags/ref_canvas.asp
                gl = canvas.getContext("experimental-webgl");

                /// Dimensions of where to display
                gl.viewportHeight = canvas.height;
                gl.viewportWidth = canvas.width;
            }
            catch(e)
            {
                alert("Not initialization available for WebGL");
            }
        }

        /// Create shaders
        var shaderProgram;

        function loadShaders()
        {
            /// Compilation
            var vertexShaderContainer;
            var vertexShader;

            /// Extract vertex shader container from the textarea of the HTML
            vertexShaderContainer = document.getElementById("inputVS");
         
            /// Here I am not sure if the member .value will be robust enough for a big project
            vertexShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertexShader, vertexShaderContainer.value);
            gl.compileShader(vertexShader);

            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS))
            {
                alert(gl.getShaderInfoLog(vertexShader));
                shadersOK = false;
                return null;
            }

            var fragmentShaderContainer;
            var fragmentShader;

            /// Extract vertex shader container from the textarea of the HTML
            fragmentShaderContainer = document.getElementById("inputFS");

            /// Here I am not sure if the member .value will be robust enough for a big project
            fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragmentShader, fragmentShaderContainer.value);
            gl.compileShader(fragmentShader);

            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS))
            {
                alert(gl.getShaderInfoLog(fragmentShader));
                shadersOK = false;
                return null;
            }

            /// Linking
            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, fragmentShader);
            gl.attachShader(shaderProgram, vertexShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS))
            {
                alert(gl.getProgramInfoLog(shaderProgram));
                shadersOK = false;
                return null;
            }

            /// Everything correct, start using shaders
            gl.useProgram(shaderProgram);
            shadersOK = true;

            /// Enable attributes
            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
            shaderProgram.vertexTextureAttribute = gl.getAttribLocation(shaderProgram, "aVertexTexture");
            shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
            shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");

            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
            gl.enableVertexAttribArray(shaderProgram.vertexTextureAttribute);
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
            gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

            /// Fetch matrix locations
            shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMV");
            shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uP");

            /// Fetch variables locations
            shaderProgram.timeUniform = gl.getUniformLocation(shaderProgram, "uTime");
        }

        /// Usage of separate buffers
        var vertexPositionBuffer;
        var vertexTextureBuffer;
        var vertexNormalBuffer;
        var vertexColorBuffer;

        function initBuffers()
        {
            /// raw 3D geometric data - positions
            vertexPositionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);

            var vertices = [-0.5, -0.5, 0.0, +0.5, -0.5, 0.0, 0.0, 0.5, 0.0];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            vertexPositionBuffer.itemSize = 3;
            vertexPositionBuffer.numItems = 3;

            /// raw RGBA color data
            vertexColorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);

            var colors = [1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
            vertexColorBuffer.itemSize = 4;
            vertexColorBuffer.numItems = 3;

            /// raw 3D geometric data - normals
            vertexNormalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);

            var normals = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
            vertexNormalBuffer.itemSize = 3;
            vertexNormalBuffer.numItems = 3;

            /// raw 2D image data
            vertexTextureBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexTextureBuffer);

            var textures = [-1.0, -1.0, +1.0, -1.0, 0.0, 1.0];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textures), gl.STATIC_DRAW);
            vertexTextureBuffer.itemSize = 2;
            vertexTextureBuffer.numItems = 3;
        }

        /// Math stuff
        var projectionMatrix = mat4.create();
        var modelviewMatrix = mat4.create();

        function setMatrixUniforms()
        {
            gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, projectionMatrix);
            gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, modelviewMatrix);
        }

        /// Animation
        var timeClientSite = 0.0;

        function setUniforms()
        {
            if (document.getElementById("checkBoxAnimation").checked)
            {
                /// I think I should add some condition to not exceed a huge number ... 
                timeClientSite += 0.01;
            }

            gl.uniform1f(shaderProgram.timeUniform, timeClientSite);
        }

        /// Draw objects
        function drawScene()
        {
            gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            /// Create perspective projection
            mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, projectionMatrix);

            /// Create modelview matrix
            mat4.identity(modelviewMatrix);
            
            if (shadersOK)
            {
                /// Bind buffers
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, vertexTextureBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexTextureAttribute, vertexTextureBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, vertexNormalBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);
                gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, vertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

                /// Set matrices in the GPU
                setMatrixUniforms();

                /// Set time for animation
                setUniforms();

                /// Finally, RENDER!
                gl.drawArrays(gl.TRIANGLES, 0, vertexPositionBuffer.numItems);
            }
        }

        /// Animation / Update
        function tick()
        {
            /// http://learningwebgl.com/blog/?p=3189
            requestAnimationFrame(tick);
            drawScene();
        }

        /// Initializer
        function WebGLInitializer(reload)
        {
            var canvas = document.getElementById("ExampleAlejandro");
            canvas.height = window.innerHeight * 0.65;
            canvas.width = window.innerWidth * 0.65;

            /// Prepare everything for the data required by WebGL
            initGL(canvas);
            initBuffers();
            loadShaders();

            /// Launch
            gl.clearColor(0.5, 0.5, 0.5, 1.0);
            gl.enable(gl.DEPTH_TEST);

            tick();
        }
    </script>

    <style>
        /*I need to take a look for the options in the CSS world*/
        nav {
            line-height:30px;
            background-color:#eeeeee;
            height:750px;
            width:475px;
            float:left;
            padding:5px;	      
        }
        section {
            width:450px;
            float:left;
            padding:10px;
        }
    </style>
    
    <!--So yeah ... -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script>
        $(document).ready(function () {
            /// Works but the formatting is not nice, plus
            /// editing is still not available
            $("#inputVS").append($("#shader-vs").text());
            $("#inputFS").append($("#shader-fs").text());
        });
    </script>
</head>
<body onload="WebGLInitializer(false)">
    <!-- The layout of the web page -->
    <nav>
        <!-- Vertex shader input -->
        <section id="vsHTML">
            <textarea type="text" cols="60" rows="29" id="inputVS"></textarea>
        </section>
        <!-- Fragment shader input -->
        <section id="fsHTML">
            <textarea type="text" cols="60" rows="14" id="inputFS"></textarea>
        </section>
        Animation <input type="checkbox" id="checkBoxAnimation"/>
        <button type="button" style="float: right;" onclick="loadShaders()">Compile</button>
    </nav>
    <section>
        <!--Our body, the beautiful stuff comes here-->
        <canvas id="ExampleAlejandro"></canvas>
    </section>
</body>
</html>